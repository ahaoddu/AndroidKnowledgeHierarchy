## 2. C/C++ so库

在 `aosp/device/mycompamy/product` 创建一下结构的目录与文件：

```bash
libmylog
├── Android.bp
├── include
│   └── mylog.h
└── mylog.cpp
```

其中 mylog.h：

```cpp
#ifndef __LOG_H__
#define __LOG_H__

#include <string>

using namespace std;

void log(string str);

#endif
```

mylog.cpp

```cpp
#include <cstdio>
#include <string>
#include "include/mylog.h""

using namespace std;

void log(string str) {
    printf("%s",str.c_str());
}
```

Android.bp

```cpp
cc_library {               //模块类型为c/c++库， 会同时编译动态库和静态库， 
                           //如果要指定编译动态库或者静态库，则应该要用 cc_library_shared 或者 cc_library_static
    name: "libmylog",       //模块名
    vendor: true,          //安装到 vendor 分区
    export_include_dirs: ["include"], //导出头文件目录，这样其他模块要使用本模块的时候，就不需要用 include_dirs 指定头文件目录了。
    srcs: ["mylog.cpp"], //源文件列表, 如果不想要一个一个列出来，
                                                       //可以使用 srcs: ["**/*.cpp"] 这种方式来查找所有的 cpp 文件。
    shared_libs: [         //依赖的动态库
        //"liblog",  
    ],
}

```

这样 so 库就写好了，下面修改第一部分 hello 模块的代码来使用 libmylog 库：

在 Android.bp 中添加库依赖：

```bash
shared_libs: [       //编译依赖的动态库
        //"liblog",
        "libmylog",
    ],
```

修改 hello.cpp：

```cpp
#include <cstdio>
#include "mylog.h"
#include <string>

using namespace std;

int main()
{
    //printf("Hello Android\n");
    log("Hello Android from myloglib\n");
    return 0;
}
```

最后编译系统，启动虚拟机，执行 hello 程序

![img](https://gitee.com/stingerzou/pic-bed/raw/master/img/20221010160729.png)

另外我们可以参考源码中的 frameworks/av/camera/Android.bp

```bash
cc_library_shared { //编译成动态库，类似于Android.mk中的BUILD_SHARED_LIBRARY
    name: "libcamera_client",
    aidl: {
        export_aidl_headers: true,  //是否导出aidl头文件路径
        local_include_dirs: ["aidl"], //将[指定的目录列表]加入aidl 搜索头文件路径。
// [“aidl”]表示当前目录下的aidl目录
        include_dirs: [ //指定搜索外部aidl头文件的路径
            "frameworks/native/aidl/gui",
        ],
    },
    srcs: [ //源文件，类似于Android.mk中的LOCAL_SRC_FILES
        // AIDL files for camera interfaces
        // The headers for these interfaces will be available to any modules that
        // include libcamera_client, at the path "aidl/package/path/BnFoo.h"
        ":libcamera_client_aidl", //引用了另外一个模块中定义的源文件。在当前bp文件的第81行
 
        // Source for camera interface parcelables, and manually-written interfaces
        "Camera.cpp",
        "CameraMetadata.cpp",
        "CameraParameters.cpp",
        "CaptureResult.cpp",
        "CameraParameters2.cpp",
        "ICamera.cpp",
        "ICameraClient.cpp",
        "ICameraRecordingProxy.cpp",
        "ICameraRecordingProxyListener.cpp",
        "camera2/CaptureRequest.cpp",
        "camera2/OutputConfiguration.cpp",
        "camera2/SessionConfiguration.cpp",
        "camera2/SubmitInfo.cpp",
        "CameraBase.cpp",
        "CameraUtils.cpp",
        "VendorTagDescriptor.cpp",
    ],
 
    shared_libs: [ //编译所依赖的动态库，类似于Android.mk中的LOCAL_SHARED_LIBRARIES
        "libcutils",
        "libutils",
        "liblog",
        "libbinder",
        "libgui",
        "libcamera_metadata",
        "libnativewindow",
    ],
 
    include_dirs: [//用户指定的头文件查找路径，类似于Android.mk中的LOCAL_C_INCLUDES
        "system/media/private/camera/include",
        "frameworks/native/include/media/openmax",
    ],
    export_include_dirs: [//将当前的路径导出，如果有其他模块引用当前模块，就不需要指定头文件路径
         "include",
         "include/camera"
    ],
    export_shared_lib_headers: ["libcamera_metadata"],//将libcamera_metadata模块对应的头文件路径列表导出
 
    cflags: [//编译flag,类似于Android.mk中的LOCAL_CFLAGS
        "-Werror",
        "-Wall",
        "-Wextra",
    ],
}

```

## 3. java 库

```bash
java_library {         //模块类型为 java 库，这个类型与 java_library_static 是完全一样的
    name: "api.pure",  //模块名
    installable: true, //下面详细说明
    enabled: true,     //是否编译这个模块，有时候我们需要根据某些条件，关闭某个模块。 
    dex_preopt: {
        enabled: false, //不做 preopt， 
    },
    srcs: [
        "java/**/*.java", //文件列表
    ],
    libs: [
        "android.hidl.manager-V1.0-java", //依赖的其他 java 库
    ],
}
```

如果不指定 installable: true, 则编译出来的 jar 包里面是 .class 文件。这种包是没法安装到系统上的，只能给其他 java 模块作为 static_libs 依赖。指定 installable: true, 则编译出来的 jar 包里面是 classes.dex 文件。这种才是 Android 虚拟机可以加载的格式。

也可以参考源码中的 frameworks/base/services/usage/Android.bp :

```bash
java_library_static {
    name: "services.usage",
    srcs: ["java/**/*.java"],
   libs: ["services.core"], //链接的动态库-./frameworks/base/services/core/Android.bp定义，
   //对应的库会生成在out/soong/.intermediates/frameworks/base/services/core/services.core
}
```

## 4. apk

这里演示一下怎么把 Android Studio 创建的项目导入到 Android 源码中。

使用 Android Studio 新建一个空项目 FirstSystemApp，java  kotlin 都可以。创建完成后，将项目移动到 aosp/home/zzh0838/Project/aosp/device/mycompamy 目录下。在项目的根目录下添加 Android.mk 文件：

```makefile
LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)

LOCAL_MODULE_TAGS := optional

LOCAL_SRC_FILES := $(call all-java-files-under,  app/src/main/java)

LOCAL_PACKAGE_NAME := FirstSystemApp

LOCAL_SDK_VERSION := current

#LOCAL_PROGUARD_FLAG_FILES := proguard.flags
LOCAL_CERTIFICATE := platform

LOCAL_USE_AAPT2 := true


# 指定Manifest文件
LOCAL_MANIFEST_FILE := app/src/main/AndroidManifest.xml

LOCAL_RESOURCE_DIR := \
	$(addprefix $(LOCAL_PATH)/, app/src/main/res) 

# constraint-layout需要的jar
LOCAL_STATIC_JAVA_LIBRARIES := \
	androidx.appcompat_appcompat  \
	androidx.recyclerview_recyclerview \
	com.google.android.material_material \
	androidx-constraintlayout_constraintlayout \


include $(BUILD_PACKAGE)

# Use the folloing include to make our test apk.
include $(call all-makefiles-under,$(LOCAL_PATH))

```

修改 AndroidManifest.xml 文件：

```makefile
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    package="com.ahaoddu.firstsystemapp">

    <application
        android:allowBackup="true"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.FirstSystemApp"
        tools:targetApi="31">
        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>

            <meta-data
                android:name="android.app.lib_name"
                android:value="" />
        </activity>
    </application>

</manifest>
```

主要修改了两个地方：

* manifest 节点添加 package 属性
* application 节点把 android:dataExtractionRules 这一行删掉。使用最新的 Android Studio 创建项目会有这个

通常开发 app 需要使用到一些库，使用 find 或者 grep 在 prebuild 下搜索，搜不到再自己导入。

当然也可以通过添加 Android.bp 来编译项目：

```makefile
android_app {
    name: "FirstSystemApp",

    srcs: ["app/src/main/java/**/*.java"],

    sdk_version: "current",

    //LOCAL_PROGUARD_FLAG_FILES := proguard.flags
    certificate: "platform",

    // 指定Manifest文件
    manifest: "app/src/main/AndroidManifest.xml",

    resource_dirs: ["app/src/main/res"],

    static_libs: ["androidx.appcompat_appcompat",
                  "androidx.recyclerview_recyclerview",
                 "com.google.android.material_material",
                 "androidx-constraintlayout_constraintlayout"],

}

// Use the folloing include to make our test apk.

```
