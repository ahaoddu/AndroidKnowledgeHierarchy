# 添加自定义模块

自定义模块就是我们添加到 Android 系统中的：

* C/C++ 可执行程序
* C/C++ so库
* Java库
* apk

## 1. C/C++ 可执行程序

在 `aosp/device/mycompamy/product` 目录下创建 hello 目录，在 hello 目录内添加 hello.cpp :

```c++
#include <cstdio>

int main()
{
    printf("Hello Android\n");
    return 0;
}

```

在 hello 目录内添加 android.bp：

```bash
cc_binary {              //模块类型为可执行文件
    name: "hello",       //模块名hello
    srcs: ["hello.cpp"], //源文件列表
    vendor: true,        //编译出来放在/vendor目录下(默认是放在/system目录下)
    shared_libs: [       //编译依赖的动态库
        //"liblog",
    ],
    cflags: ["-Werror"], //添加编译选项
}
```

在 `aosp/device/mycompamy/product/myaosp.mk` 中添加：

```bash
PRODUCT_PACKAGES += hello
```

接下来编译系统：

```bash
source build/envsetup.sh
lunch myaosp-eng
make -j16
```

编译完成启动虚拟机后，就可以通过 adb shell 运行我们的 hello 程序了

```bash
adb shell hello
```

执行结果如下图所示：

![](https://gitee.com/stingerzou/pic-bed/raw/master/img/20221010154219.png)


另外我们可以参考源码中的 system/core/reboot/Android.bp 

```bash

cc_binary {
    name: "reboot",
    srcs: ["reboot.c"],
    shared_libs: ["libcutils"],
    cflags: ["-Werror"],

```

## 2. C/C++ so库

在 `aosp/device/mycompamy/product` 创建一下结构的目录与文件：

```bash
libmylog
├── Android.bp
├── include
│   └── mylog.h
└── mylog.cpp
```

其中 mylog.h：

```cpp
#ifndef __LOG_H__
#define __LOG_H__

#include <string>

using namespace std;

void log(string str);

#endif
```

mylog.cpp

```cpp
#include <cstdio>
#include <string>
#include "include/mylog.h""

using namespace std;

void log(string str) {
    printf("%s",str.c_str());
}
```

Android.bp

```cpp
cc_library {               //模块类型为c/c++库， 会同时编译动态库和静态库， 
                           //如果要指定编译动态库或者静态库，则应该要用 cc_library_shared 或者 cc_library_static
    name: "libmylog",       //模块名
    vendor: true,          //安装到 vendor 分区
    export_include_dirs: ["include"], //导出头文件目录，这样其他模块要使用本模块的时候，就不需要用 include_dirs 指定头文件目录了。
    srcs: ["mylog.cpp"], //源文件列表, 如果不想要一个一个列出来，
                                                       //可以使用 srcs: ["**/*.cpp"] 这种方式来查找所有的 cpp 文件。
    shared_libs: [         //依赖的动态库
        //"liblog",  
    ],
}

```

这样 so 库就写好了，下面修改第一部分 hello 模块的代码来使用 libmylog 库：

在 Android.bp 中添加库依赖：

```bash
shared_libs: [       //编译依赖的动态库
        //"liblog",
        "libmylog",
    ],
```

修改 hello.cpp：

```cpp
#include <cstdio>
#include "mylog.h"
#include <string>

using namespace std;

int main()
{
    //printf("Hello Android\n");
    log("Hello Android from myloglib\n");
    return 0;
}
```

最后编译系统，启动虚拟机，执行 hello 程序

![img](https://gitee.com/stingerzou/pic-bed/raw/master/img/20221010160729.png)


另外我们可以参考源码中的 frameworks/av/camera/Android.bp

```bash
cc_library_shared { //编译成动态库，类似于Android.mk中的BUILD_SHARED_LIBRARY
    name: "libcamera_client",
    aidl: {
        export_aidl_headers: true,  //是否导出aidl头文件路径
        local_include_dirs: ["aidl"], //将[指定的目录列表]加入aidl 搜索头文件路径。
// [“aidl”]表示当前目录下的aidl目录
        include_dirs: [ //指定搜索外部aidl头文件的路径
            "frameworks/native/aidl/gui",
        ],
    },
    srcs: [ //源文件，类似于Android.mk中的LOCAL_SRC_FILES
        // AIDL files for camera interfaces
        // The headers for these interfaces will be available to any modules that
        // include libcamera_client, at the path "aidl/package/path/BnFoo.h"
        ":libcamera_client_aidl", //引用了另外一个模块中定义的源文件。在当前bp文件的第81行
 
        // Source for camera interface parcelables, and manually-written interfaces
        "Camera.cpp",
        "CameraMetadata.cpp",
        "CameraParameters.cpp",
        "CaptureResult.cpp",
        "CameraParameters2.cpp",
        "ICamera.cpp",
        "ICameraClient.cpp",
        "ICameraRecordingProxy.cpp",
        "ICameraRecordingProxyListener.cpp",
        "camera2/CaptureRequest.cpp",
        "camera2/OutputConfiguration.cpp",
        "camera2/SessionConfiguration.cpp",
        "camera2/SubmitInfo.cpp",
        "CameraBase.cpp",
        "CameraUtils.cpp",
        "VendorTagDescriptor.cpp",
    ],
 
    shared_libs: [ //编译所依赖的动态库，类似于Android.mk中的LOCAL_SHARED_LIBRARIES
        "libcutils",
        "libutils",
        "liblog",
        "libbinder",
        "libgui",
        "libcamera_metadata",
        "libnativewindow",
    ],
 
    include_dirs: [//用户指定的头文件查找路径，类似于Android.mk中的LOCAL_C_INCLUDES
        "system/media/private/camera/include",
        "frameworks/native/include/media/openmax",
    ],
    export_include_dirs: [//将当前的路径导出，如果有其他模块引用当前模块，就不需要指定头文件路径
         "include",
         "include/camera"
    ],
    export_shared_lib_headers: ["libcamera_metadata"],//将libcamera_metadata模块对应的头文件路径列表导出
 
    cflags: [//编译flag,类似于Android.mk中的LOCAL_CFLAGS
        "-Werror",
        "-Wall",
        "-Wextra",
    ],
}

```

## 3. java 库

```bash
java_library {         //模块类型为 java 库，这个类型与 java_library_static 是完全一样的
    name: "api.pure",  //模块名
    installable: true, //下面详细说明
    enabled: true,     //是否编译这个模块，有时候我们需要根据某些条件，关闭某个模块。 
    dex_preopt: {
        enabled: false, //不做 preopt， 
    },
    srcs: [
        "java/**/*.java", //文件列表
    ],
    libs: [
        "android.hidl.manager-V1.0-java", //依赖的其他 java 库
    ],
}
```

如果不指定 installable: true, 则编译出来的 jar 包里面是 .class 文件。这种包是没法安装到系统上的，只能给其他 java 模块作为 static_libs 依赖。指定 installable: true, 则编译出来的 jar 包里面是 classes.dex 文件。这种才是 Android 虚拟机可以加载的格式。

也可以参考源码中的 frameworks/base/services/usage/Android.bp :

```bash
java_library_static {
    name: "services.usage",
    srcs: ["java/**/*.java"],
   libs: ["services.core"], //链接的动态库-./frameworks/base/services/core/Android.bp定义，
   //对应的库会生成在out/soong/.intermediates/frameworks/base/services/core/services.core
}
```

## 4. apk

可以参考：

packages/apps/Music/Android.bp

packages/apps/QuickSearchBox/Android.bp

packages/apps/Nfc/Android.bp

```bash
android_app {
    name: "Music",
    srcs: [
        "src/**/*.java",
        "src/com/android/music/IMediaPlaybackService.aidl",
    ],
    sdk_version: "current",
    product_specific: true, //安装到product分区
    optimize: {
        proguard_flags_files: ["proguard.flags"],
    },
    certificate: "platform",
}
```


## 参考资料

* [Android系统开发入门-4.添加自定义模块](http://qiushao.net/2019/11/22/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/4-%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/)
* [Android 10 根文件系统和编译系统(十九)：Android.bp各种模块编译规则](https://blog.csdn.net/ldswfun/article/details/120834205?spm=1001.2014.3001.5502)
* [Soong Modules Reference](https://ci.android.com/builds/submitted/9155974/linux/latest/view/soong_build.html)
